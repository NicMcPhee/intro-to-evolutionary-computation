<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-08-18T17:05:50-05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Your awesome title</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Implementing simple search in Clojure</title><link href="http://localhost:4000/search/clojure/2019/08/17/implementing-search-in-clojure.html" rel="alternate" type="text/html" title="Implementing simple search in Clojure" /><published>2019-08-17T17:06:02-05:00</published><updated>2019-08-17T17:06:02-05:00</updated><id>http://localhost:4000/search/clojure/2019/08/17/implementing-search-in-clojure</id><content type="html" xml:base="http://localhost:4000/search/clojure/2019/08/17/implementing-search-in-clojure.html">&lt;p&gt;lskjdflskjf
lskdjflsjkd
lskjdfskjld&lt;/p&gt;

&lt;p&gt;Can I load up &lt;code class=&quot;highlighter-rouge&quot;&gt;klipse&lt;/code&gt; and get it to work here in Jekyll?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-klipse&quot;&gt;(+ 2 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Huzzah!&lt;/p&gt;</content><author><name></name></author><summary type="html">lskjdflskjf lskdjflsjkd lskjdfskjld</summary></entry><entry><title type="html">Does klipse work?</title><link href="http://localhost:4000/jekyll/klipse/2019/08/16/klipse-test.html" rel="alternate" type="text/html" title="Does klipse work?" /><published>2019-08-16T21:10:02-05:00</published><updated>2019-08-16T21:10:02-05:00</updated><id>http://localhost:4000/jekyll/klipse/2019/08/16/klipse-test</id><content type="html" xml:base="http://localhost:4000/jekyll/klipse/2019/08/16/klipse-test.html">&lt;h1 id=&quot;simple-example-of-search&quot;&gt;Simple example of search&lt;/h1&gt;

&lt;p&gt;Let us first consider an &lt;em&gt;extremely&lt;/em&gt; (&amp;amp; deliberately) simple example. Imagine
a little robot, Pat, on an integer grid at position (10, 10) who needs to get to
(0, 0).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simple_search_grid.svg&quot; alt=&quot;Integer grid with robot at (10, 10) and goal at (0, 0).&quot; width=&quot;75%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Our friend Pat can only go left-right and up-down. They can’t cut across
diagonals – imagine it’s a city street map and they can’t wander through
random office buildings.&lt;/p&gt;

&lt;p&gt;How might we frame this as a search problem? Let us first represent Pat’s
&lt;em&gt;state&lt;/em&gt;, which for our purposes is just Pat’s position on the grid as an
ordered pair &lt;script type=&quot;math/tex&quot;&gt;(x, y)&lt;/script&gt;. &lt;input type=&quot;checkbox&quot; id=&quot;cb1&quot; /&gt;&lt;label for=&quot;cb1&quot;&gt;&lt;sup class=&quot;note-marker&quot;&gt;*&lt;/sup&gt;&lt;/label&gt;&lt;span&gt;Pat’s state could be a pretty complex thing, including the state of their batteries,
the urgency of the current goal, etc., but we’re going to ignore all that for
now.&lt;/span&gt; Thus in our example Pat’s &lt;em&gt;initial state&lt;/em&gt; is (10, 10) and
their &lt;em&gt;goal state&lt;/em&gt; is (0, 0). At each time step Pat can make one of four moves:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;up&lt;/code&gt;, which takes the state &lt;script type=&quot;math/tex&quot;&gt;(x, y)&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;(x, y+1)&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;down&lt;/code&gt;, which takes the state &lt;script type=&quot;math/tex&quot;&gt;(x, y)&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;(x, y-1)&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;left&lt;/code&gt;, which takes the state &lt;script type=&quot;math/tex&quot;&gt;(x, y)&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;(x-1, y)&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;right&lt;/code&gt;, which takes the state &lt;script type=&quot;math/tex&quot;&gt;(x, y)&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;(x+1, y)&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A &lt;em&gt;solution&lt;/em&gt; for this problem is then a sequence of moves that takes Pat from
(10, 10) to (0, 0). As is typically the case, there are many possible solutions.
Some are in some sense “optimal”; here the solution that goes &lt;code class=&quot;highlighter-rouge&quot;&gt;left&lt;/code&gt; 10 times
and then &lt;code class=&quot;highlighter-rouge&quot;&gt;down&lt;/code&gt; 10 times is one of many examples of a &lt;em&gt;shortest&lt;/em&gt; solution.&lt;/p&gt;

&lt;p&gt;The idea then is to &lt;em&gt;search&lt;/em&gt; for a solution (a sequence of moves) that gets
Pat from their start state to their goal state. A common way of visualizing
this is as a &lt;em&gt;search tree&lt;/em&gt;, where each &lt;em&gt;node&lt;/em&gt; represents a state of the system
(Pat’s position in our case) and its &lt;em&gt;children&lt;/em&gt; represent the states reachable
from the &lt;em&gt;parent&lt;/em&gt; state.&lt;/p&gt;

&lt;p&gt;The diagram below illustrates Pat starting at (10, 10) and exploring a few
paths:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/simple_search_tree.svg&quot; alt=&quot;A subset of the first few levels of a search tree.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At the first step, Pat has four options:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;up&lt;/code&gt;, which goes to (10, 11)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;down&lt;/code&gt;, which goes to (10, 9)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;left&lt;/code&gt;, which goes to (9, 10)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;right&lt;/code&gt;, which goes to (11, 10)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From each of those new positions, Pat again has
four options, one of which (&lt;code class=&quot;highlighter-rouge&quot;&gt;left&lt;/code&gt;) leads to (9, 9); to keep the size of the
diagram manageable we’ve omitted the other three states. From (9, 9) there are
again four options, as illustrated in the figure.&lt;/p&gt;

&lt;h1 id=&quot;the-size-of-search-trees&quot;&gt;The size of search trees&lt;/h1&gt;

&lt;p&gt;In theory Pat could find a path to (0, 0) by simply expanding this tree until
they find the desired node. Even in this very simple example, however, this
quickly becomes infeasible as the number of states that need to be explored
grows rapidly as one expands down the tree. Here, for example, the number of
nodes at level &lt;script type=&quot;math/tex&quot;&gt;N+1&lt;/script&gt; is four times the number of nodes at level &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; because
each node has four children. Thus the number of nodes at level &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;4^N&lt;/script&gt;,
and expanding the tree down the 20 levels necessary for a &lt;em&gt;minimal&lt;/em&gt; solution
leads to a level with &lt;script type=&quot;math/tex&quot;&gt;4^{20} = 1,099,511,627,776 \approx 10^{12}&lt;/script&gt; nodes!
And that’s just for this very simple example; more realistic search spaces
tend to be be &lt;em&gt;much&lt;/em&gt; larger; &lt;a href=&quot;https://math.stackexchange.com/questions/1406919/how-many-legal-states-of-chess-exists&quot;&gt;the number of legal chess configurations is
estimated to be in the neighborhood of &lt;script type=&quot;math/tex&quot;&gt;10^{45}&lt;/script&gt;&lt;/a&gt;. The numbers for the game
of go &lt;a href=&quot;https://senseis.xmp.net/?NumberOfPossibleGoGames&quot;&gt;are much larger still&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Statistics from real games between professional players show that it is
extremely rare for a game to last more than 400 moves. If, on average, there are
100 legal moves in every position, then the possible number of games of length
400 or less is in the order of &lt;script type=&quot;math/tex&quot;&gt;10^{800}&lt;/script&gt;, corresponding to around
&lt;script type=&quot;math/tex&quot;&gt;10^{720}&lt;/script&gt; possible games for every atom in the known universe. – &lt;a href=&quot;https://senseis.xmp.net/?NumberOfPossibleGoGames&quot;&gt;senseis.xmp.net&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yikes!&lt;/p&gt;

&lt;h1 id=&quot;repetition-and-search-trees&quot;&gt;Repetition and search trees&lt;/h1&gt;

&lt;p&gt;The search tree above also illustrates an annoying property of most search
trees: there is often repetition, and frequently lots of it. In our diagram
there are two instances of (10, 9) shown, and in fact there are many more
duplicates if we expand the nodes below the first instance of (10, 9) on
the level with depth 1. As we expand farther and farther down we’ll find more and
more duplicates; every level with an even depth, for example, will have an
increasing number of copies of (10, 10) that result from sequences that “undo”
all their work such as &lt;code class=&quot;highlighter-rouge&quot;&gt;up-down-down-up&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;left-down-right-up&lt;/code&gt;. As we’ll
see later, we’ll probably want our search techniques to avoid
repeatedly processing duplicate states.&lt;/p&gt;

&lt;p&gt;There can, however, be times when we want to
revisit a state. If the first time we visited a state it was very
“expensive” to get there (e.g., required many moves), we might have then
decided we didn’t
want to further explore that state. If we later find a “cheaper” way to reach
that state, then our interest in it might increase and we might
want to (re)explore the paths from that state.&lt;/p&gt;

&lt;h1 id=&quot;next-implementing-these-ideas-in-clojure&quot;&gt;Next: Implementing these ideas in Clojure&lt;/h1&gt;

&lt;p&gt;In the next installment we’ll look at how to actually generate these kinds of
search trees in Clojure, and some simple algorithms for searching them.&lt;/p&gt;</content><author><name></name></author><summary type="html">Simple example of search</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/jekyll/update/2019/08/16/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2019-08-16T21:10:02-05:00</published><updated>2019-08-16T21:10:02-05:00</updated><id>http://localhost:4000/jekyll/update/2019/08/16/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/16/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry></feed>